<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three.js + Spatial Audio + Reactive Melody</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js"></script>

<script>
// -------------------------------------------------------
//  Scene + Camera + Renderer
// -------------------------------------------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 2, 6);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// -------------------------------------------------------
//  3D Objects
// -------------------------------------------------------
const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
sphere.position.set(0, 1, 0);
scene.add(sphere);

const grid = new THREE.GridHelper(50, 50);
scene.add(grid);

// -------------------------------------------------------
//  Lights
// -------------------------------------------------------
const light1 = new THREE.DirectionalLight(0xffffff, 1);
light1.position.set(5, 10, 7);
scene.add(light1);

const ambient = new THREE.AmbientLight(0xffffff, 0.3);
scene.add(ambient);

// -------------------------------------------------------
//  SPATIAL AUDIO SETUP
// -------------------------------------------------------
const listener = new THREE.AudioListener();
camera.add(listener);

// Reactive spatial audio source
const audio = new THREE.PositionalAudio(listener);

// WebAudio oscillator — dynamic staccato melody
const audioCtx = listener.context;
let osc = audioCtx.createOscillator();
let gain = audioCtx.createGain();

osc.type = "sine";
osc.frequency.value = 440;  // Will change interactively

gain.gain.setValueAtTime(0, audioCtx.currentTime);

// Connect oscillator → gain → positional audio node
osc.connect(gain);
gain.connect(audio.panner); // Three.js positional audio
osc.start();

// Attach positional audio to sphere
sphere.add(audio);

// Inverse distance model + realistic spatial behavior
audio.setRefDistance(2);
audio.setDistanceModel("inverse");
audio.panner.panningModel = "HRTF"; // Accurate stereo cues

// -------------------------------------------------------
//  Melody Logic (Reactive Staccato Sound)
// -------------------------------------------------------
let lastNoteTime = 0;

function playReactiveNote(dist, time) {
  const minInterval = 0.1;
  const maxInterval = 0.6;

  const interval = THREE.MathUtils.clamp(dist / 8, minInterval, maxInterval);

  if (time - lastNoteTime < interval) return;
  lastNoteTime = time;

  // Pitch increases closer to sphere
  const baseFreq = 200;
  const freq = baseFreq + (1 / (dist + 0.1)) * 600;
  osc.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.01);

  // Staccato envelope
  gain.gain.cancelScheduledValues(audioCtx.currentTime);
  gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
  gain.gain.setTargetAtTime(0.0, audioCtx.currentTime + 0.1, 0.05);
}

// -------------------------------------------------------
//  Keyboard Movement
// -------------------------------------------------------
const keys = {};
window.addEventListener("keydown", (e) => (keys[e.key.toLowerCase()] = true));
window.addEventListener("keyup", (e) => (keys[e.key.toLowerCase()] = false));

function handleMovement(delta) {
  const speed = 5 * delta;
  const rotSpeed = 1.5 * delta;

  if (keys["w"] || keys["arrowup"]) {
    camera.position.x -= Math.sin(camera.rotation.y) * speed;
    camera.position.z -= Math.cos(camera.rotation.y) * speed;
  }
  if (keys["s"] || keys["arrowdown"]) {
    camera.position.x += Math.sin(camera.rotation.y) * speed;
    camera.position.z += Math.cos(camera.rotation.y) * speed;
  }
  if (keys["a"]) {
    camera.position.x -= Math.cos(camera.rotation.y) * speed;
    camera.position.z += Math.sin(camera.rotation.y) * speed;
  }
  if (keys["d"]) {
    camera.position.x += Math.cos(camera.rotation.y) * speed;
    camera.position.z -= Math.sin(camera.rotation.y) * speed;
  }

  if (keys["arrowleft"]) camera.rotation.y += rotSpeed;
  if (keys["arrowright"]) camera.rotation.y -= rotSpeed;
}

// -------------------------------------------------------
//  Animation Loop
// -------------------------------------------------------
let lastTime = 0;

function animate(time) {
  requestAnimationFrame(animate);

  let delta = (time - lastTime) / 1000;
  lastTime = time;

  handleMovement(delta);

  // -----------------------------
  // Spatial Audio Listener Update
  // -----------------------------
  const camDir = new THREE.Vector3();
  camera.getWorldDirection(camDir);

  listener.position.copy(camera.position);
  listener.setOrientation(
    camDir.x, camDir.y, camDir.z,
    0, 1, 0 // World up vector
  );

  // Distance to sphere → reactive melody
  const dist = camera.position.distanceTo(sphere.position);
  playReactiveNote(dist, time / 1000);

  renderer.render(scene, camera);
}

animate(0);

// -------------------------------------------------------
//  Resize Handling
// -------------------------------------------------------
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
