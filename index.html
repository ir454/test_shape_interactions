<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Polyphonic C-minor Audio</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
let scene, camera, renderer;
let circles = [];
let audioCtx, audioStarted = false;

const melody = [261.63, 293.66, 311.13, 349.23, 392.00, 415.30, 466.16]; // C minor
const ADSR = { attack: 0.15, decay: 0.2, sustain: 0.5, release: 0.4 };

// Initialize Three.js
function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.z = 8;
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const geometry = new THREE.CircleGeometry(0.5, 32);
    for (let i = 0; i < 4; i++) {
        const material = new THREE.MeshStandardMaterial({color: 0xffffff, emissive:0x000000});
        const circle = new THREE.Mesh(geometry, material);
        circle.position.x = (i-1.5)*2;
        circle.position.y = 0;
        circle.targetColor = new THREE.Color(0xffffff);
        circle.currentColor = new THREE.Color(0xffffff);
        scene.add(circle);
        circles.push(circle);
    }

    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
    dirLight.position.set(5,5,5);
    scene.add(dirLight);

    // Initialize Audio
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    circles.forEach(()=> {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        gain.gain.value = 0;
        osc.connect(gain).connect(audioCtx.destination);
        osc.start();
        audioData.push({
            osc: osc,
            gain: gain,
            nextNoteTime: 0,
            currentFreq: 440
        });
    });

    animate();
}

let audioData = [];

// Schedule melody notes with smooth ADSR
function updateMelody(){
    if(!audioStarted) return;
    const now = audioCtx.currentTime;
    audioData.forEach((c,i)=>{
        if(now >= c.nextNoteTime){
            const idx = Math.floor(Math.random()*melody.length);
            const freq = melody[idx];
            const color = new THREE.Color(`hsl(${Math.random()*360},100%,50%)`);
            circles[i].targetColor.copy(color);

            c.osc.frequency.setValueAtTime(freq, now);

            const g = c.gain.gain;
            g.cancelScheduledValues(now);
            g.setValueAtTime(0.0001, now);
            g.linearRampToValueAtTime(0.6, now+ADSR.attack);
            g.linearRampToValueAtTime(ADSR.sustain*0.6, now+ADSR.attack+ADSR.decay);
            g.setValueAtTime(ADSR.sustain*0.6, now+ADSR.attack+ADSR.decay);
            g.linearRampToValueAtTime(0.0001, now+ADSR.attack+ADSR.decay+ADSR.release);

            c.nextNoteTime = now + 0.6 + Math.random()*0.8;
            c.currentFreq = freq;
        }
    });
}

// Update circle colors smoothly
function updateCirclesVisuals(){
    circles.forEach(c => {
        c.currentColor.lerp(c.targetColor, 0.02);
        c.material.color.copy(c.currentColor);
        c.material.emissive.copy(c.currentColor);
    });
}

// Animate
function animate(){
    requestAnimationFrame(animate);
    updateMelody();
    updateCirclesVisuals();
    renderer.render(scene,camera);
}

// Start audio on first user interaction
document.body.addEventListener('click',()=>{
    if(!audioStarted){
        audioCtx.resume();
        audioStarted=true;
    }
});

init();
</script>
</body>
</html>
