for (let i = 0; i < 4; i++) {
    const circleData = circles[i];
    const time = performance.now() / 1000;
    circleData.mesh.position.y = circleData.baseY + Math.sin(time + i) * 0.3;

    // Smooth color
    circleData.currentColor.lerp(circleData.targetColor, 0.02);
    circleData.mesh.material.color.copy(circleData.currentColor);
    circleData.mesh.material.emissive.copy(circleData.currentColor);

    // Visual ADSR scaling
    const cAudio = circleAudio[i];
    if (cAudio.visualStartTime) {
        const t = audioCtx.currentTime - cAudio.visualStartTime;
        let scale = 1.0;
        if (t < ADSR.attack) scale = 1 + 0.5 * (t / ADSR.attack); // Attack
        else if (t < ADSR.attack + ADSR.decay) scale = 1.5 - 0.1 * ((t - ADSR.attack) / ADSR.decay); // Decay
        else if (t < ADSR.attack + ADSR.decay + ADSR.release) scale = 1.4 * (1 - (t - ADSR.attack - ADSR.decay) / ADSR.release); // Release
        else scale = 1.0;
        circleData.mesh.scale.set(scale, scale, scale);
    }

    // Segments (lines) still follow amplitude
    const segs = circleSegments[i];
    for (let j = 0; j < segs.length; j++) {
        const seg = segs[j];
        const freq = cAudio?.currentFreq || 440;
        const amp = cAudio?.currentVolume || 0;
        const len = 2 * (0.5 + amp) * Math.sin(freq * time + j);
        const positions = seg.geom.attributes.position.array;
        positions[0] = 0; positions[1] = 0; positions[2] = 0;
        positions[3] = 0; positions[4] = len; positions[5] = 0;
        seg.geom.attributes.position.needsUpdate = true;
        const brightness = 0.5 + 0.5 * amp;
        seg.line.material.color.copy(circleData.currentColor).multiplyScalar(brightness);
    }
}
