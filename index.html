<!DOCTYPE html> 
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Audio Visual Experience</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
  canvas { display: block; }
  #uiContainer {
    position: absolute;
    top: 10px;
    left: 10px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    background: rgba(0,0,0,0.4);
    padding: 10px;
    border-radius: 8px;
  }
  #timer { font-size: 28px; color: white; font-weight: bold; text-align: center; }
  #startAudio {
    padding: 8px 16px;
    background: #ff4444;
    color: white;
    font-size: 16px;
    border: none;
    cursor: pointer;
    border-radius: 6px;
  }
  #miniMap {
    width: 150px;
    height: 150px;
    background: #111;
    border: 2px solid white;
    border-radius: 6px;
  }
</style>
</head>
<body>
<div id="uiContainer">
  <div id="timer">05:00</div>
  <canvas id="miniMap"></canvas>
  <button id="startAudio">Click to Enable Sound</button>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

// -------------------- SIMPLEX / PERLIN NOISE --------------------
class PerlinNoise{
    constructor(){
        this.grad3 = [
            [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
            [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
            [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
        ];
        this.p = [];
        for(let i=0;i<256;i++) this.p[i]=Math.floor(Math.random()*256);
        this.perm = [];
        for(let i=0;i<512;i++) this.perm[i]=this.p[i & 255];
    }
    dot(g, x, y, z){ return g[0]*x+g[1]*y+g[2]*z; }
    noise(x, y, z){
        const floorX=Math.floor(x), floorY=Math.floor(y), floorZ=Math.floor(z);
        const X=floorX&255, Y=floorY&255, Z=floorZ&255;
        x-=floorX; y-=floorY; z-=floorZ;
        const u=x*x*x*(x*(x*6-15)+10);
        const v=y*y*y*(y*(y*6-15)+10);
        const w=z*z*z*(z*(z*6-15)+10);
        const A=this.perm[X]+Y, AA=this.perm[A]+Z, AB=this.perm[A+1]+Z;
        const B=this.perm[X+1]+Y, BA=this.perm[B]+Z, BB=this.perm[B+1]+Z;
        const gAA=this.grad3[this.perm[AA]%12], gBA=this.grad3[this.perm[BA]%12];
        const gAB=this.grad3[this.perm[AB]%12], gBB=this.grad3[this.perm[BB]%12];
        const gAA1=this.grad3[this.perm[AA+1]%12], gBA1=this.grad3[this.perm[BA+1]%12];
        const gAB1=this.grad3[this.perm[AB+1]%12], gBB1=this.grad3[this.perm[BB+1]%12];
        const lerp=(a,b,t)=>a+(b-a)*t;
        const n000=this.dot(gAA,x,y,z);
        const n100=this.dot(gBA,x-1,y,z);
        const n010=this.dot(gAB,x,y-1,z);
        const n110=this.dot(gBB,x-1,y-1,z);
        const n001=this.dot(gAA1,x,y,z-1);
        const n101=this.dot(gBA1,x-1,y,z-1);
        const n011=this.dot(gAB1,x,y-1,z-1);
        const n111=this.dot(gBB1,x-1,y-1,z-1);
        const nx00=lerp(n000,n100,u), nx01=lerp(n001,n101,u);
        const nx10=lerp(n010,n110,u), nx11=lerp(n011,n111,u);
        const nxy0=lerp(nx00,nx10,v), nxy1=lerp(nx01,nx11,v);
        return lerp(nxy0,nxy1,w);
    }
}
const perlin = new PerlinNoise();

// -------------------- SCENE --------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 200);
camera.position.set(0,1.5,15);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// -------------------- FLOOR --------------------
const floorSize = 60;
const floorSegments = 60;
const floorGeometry = new THREE.PlaneGeometry(floorSize,floorSize,floorSegments,floorSegments);
const floorMaterial = new THREE.MeshBasicMaterial({color:0xffffff, wireframe:true, transparent:true, opacity:0.5});
const floorMesh = new THREE.Mesh(floorGeometry,floorMaterial);
floorMesh.rotation.x=-Math.PI/2;
scene.add(floorMesh);

// -------------------- LIGHT --------------------
const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(5,10,7);
scene.add(light);

// -------------------- FLOATING CIRCLES --------------------
const circles=[];
const circlePositions = [
    new THREE.Vector3(-10,0.5,-10),
    new THREE.Vector3(10,0.5,-10),
    new THREE.Vector3(-10,0.5,10),
    new THREE.Vector3(10,0.5,10)
];
const neonColors=[0xff00ff,0x00ffff,0xffff00,0xff5500];
for(let i=0;i<4;i++){
    const mat = new THREE.MeshStandardMaterial({color:neonColors[i],emissive:neonColors[i],emissiveIntensity:0.6});
    const circle = new THREE.Mesh(new THREE.SphereGeometry(1,16,16), mat);
    circle.position.copy(circlePositions[i]);
    scene.add(circle);
    circles.push({mesh:circle, currentColor:new THREE.Color(neonColors[i]), targetColor:new THREE.Color(neonColors[i]), baseY:circle.position.y});
}

// -------------------- SEGMENTS --------------------
const segmentsPerCircle = 15;
const circleSegments=[];
for(let i=0;i<4;i++){
    const segs=[];
    for(let j=0;j<segmentsPerCircle;j++){
        const geom = new THREE.BufferGeometry();
        const positions = new Float32Array(6);
        geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
        const mat = new THREE.LineBasicMaterial({color:neonColors[i]});
        const line = new THREE.Line(geom, mat);
        scene.add(line);
        segs.push({line, geom});
    }
    circleSegments.push(segs);
}

// -------------------- USER MOVEMENT --------------------
const keys={};
document.addEventListener("keydown", e=>keys[e.key]=true);
document.addEventListener("keyup", e=>delete keys[e.key]);
let yaw=0, pitch=0;

function updateMovement(){
    const moveSpeed=0.13, rotSpeed=0.02;
    if(keys["ArrowLeft"]) yaw += rotSpeed;
    if(keys["ArrowRight"]) yaw -= rotSpeed;
    if(keys["ArrowUp"]) pitch += rotSpeed;
    if(keys["ArrowDown"]) pitch -= rotSpeed;
    camera.rotation.set(pitch,yaw,0);
    const forward = new THREE.Vector3(-Math.sin(yaw),0,-Math.cos(yaw));
    const right = new THREE.Vector3(Math.cos(yaw),0,-Math.sin(yaw));
    if(keys["w"]||keys["W"]) camera.position.addScaledVector(forward,moveSpeed);
    if(keys["s"]||keys["S"]) camera.position.addScaledVector(forward,-moveSpeed);
    if(keys["a"]||keys["A"]) camera.position.addScaledVector(right,-moveSpeed);
    if(keys["d"]||keys["D"]) camera.position.addScaledVector(right,moveSpeed);
    if(keys["1"]){circles[0].mesh.position.copy(camera.position); circles[0].mesh.position.y=1; delete keys["1"];}
    if(keys["2"]){circles[1].mesh.position.copy(camera.position); circles[1].mesh.position.y=1; delete keys["2"];}
    if(keys["3"]){circles[2].mesh.position.copy(camera.position); circles[2].mesh.position.y=1; delete keys["3"];}
    if(keys["4"]){circles[3].mesh.position.copy(camera.position); circles[3].mesh.position.y=1; delete keys["4"];}
}

// -------------------- AUDIO --------------------
let audioCtx, audioStarted=false;
const circleAudio=[];

// --- C-minor pentatonic over 3 octaves ---
const baseMelody = [261.63, 311.13, 349.23, 392.00, 466.16];
const melody = [];
for(let o=0;o<3;o++){ 
    const octaveMul = Math.pow(2,o);
    baseMelody.forEach(n=>melody.push(n*octaveMul));
}

function createImpulseResponse(ctx,duration=1.0,decay=1.0){
    const rate=ctx.sampleRate;
    const length=rate*duration;
    const impulse=ctx.createBuffer(2,length,rate);
    const left=impulse.getChannelData(0);
    const right=impulse.getChannelData(1);
    for(let i=0;i<length;i++){
        const n=(length-i)/length;
        const v=Math.random()*Math.pow(n,decay);
        left[i]=v; right[i]=v;
    }
    return impulse;
}

function startAudio(){
    audioCtx=new AudioContext();
    const reverb=createImpulseResponse(audioCtx);
    for(let i=0;i<4;i++){
        const osc=audioCtx.createOscillator();
        osc.type="triangle";
        const panner=audioCtx.createPanner();
        panner.panningModel="HRTF"; panner.refDistance=1.0; panner.maxDistance=60; panner.rolloffFactor=0.8;
        const lowpass=audioCtx.createBiquadFilter(); lowpass.type="lowpass"; lowpass.frequency.value=20000;
        const convolver=audioCtx.createConvolver(); convolver.buffer=reverb;
        const reverbGain=audioCtx.createGain(); reverbGain.gain.value=0.10;
        const gain=audioCtx.createGain(); gain.gain.value=0;
        osc.connect(panner); panner.connect(lowpass); lowpass.connect(gain); gain.connect(audioCtx.destination);
        osc.connect(convolver); convolver.connect(reverbGain); reverbGain.connect(audioCtx.destination);
        osc.start();
        circleAudio.push({
            osc,
            gain,
            panner,
            lowpass,
            nextNoteTime: audioCtx.currentTime + Math.random()*1.5,
            noteDuration: 0.2 + Math.random()*0.2,
            currentFreq: 0,
            currentVolume: 0,
            lastNoteColor: new THREE.Color(neonColors[i]),
            pointillistic: false
        });
    }
    audioStarted=true;
    document.getElementById("startAudio").style.display="none";
    startTimer();
}

// -------------------- TIMER --------------------
let timerSeconds=300, timerInterval=null;
function startTimer(){
    timerInterval=setInterval(()=>{
        timerSeconds--;
        if(timerSeconds===240) startDrumMachine();
        if(timerSeconds===120) stopDrumMachine();
        if(timerSeconds===60){
            circleAudio.forEach(c=>c.pointillistic=true);
        }
        if(timerSeconds <= 10 && timerSeconds > 0 && audioStarted){
            const fadeGain = timerSeconds / 10; 
            circleAudio.forEach(c=>{
                c.gain.gain.linearRampToValueAtTime(fadeGain * 0.3, audioCtx.currentTime + 0.1);
            });
        }
        const min=Math.floor(timerSeconds/60).toString().padStart(2,'0');
        const sec=(timerSeconds%60).toString().padStart(2,'0');
        document.getElementById("timer").innerText=min+":"+sec;
    },1000);
}

// -------------------- POLYPHONIC MELODY --------------------
function updateMelody(){
    if(!audioStarted) return;
    const now = audioCtx.currentTime;
    circleAudio.forEach((c, i)=>{
        if(now >= c.nextNoteTime){
            const idx = Math.floor(Math.random()*melody.length);
            const freq = melody[idx];
            const color = new THREE.Color(`hsl(${Math.random()*360},100%,50%)`);
            circles[i].targetColor.copy(color); c.lastNoteColor=color;

            c.osc.frequency.cancelScheduledValues(now);
            c.osc.frequency.setValueAtTime(c.currentFreq || freq, now);
            c.osc.frequency.exponentialRampToValueAtTime(freq, now + 0.08);

            const g = c.gain.gain;
            g.cancelScheduledValues(now);

            if(c.pointillistic){
                g.setValueAtTime(0.0001, now);
                g.linearRampToValueAtTime(0.3, now + 0.02);
                g.linearRampToValueAtTime(0.0001, now + 0.08);
                c.noteDuration = 0.05 + Math.random()*0.1;
                c.nextNoteTime = now + 0.15 + Math.random()*0.2;
            } else {
                g.setValueAtTime(0.0001, now);
                g.linearRampToValueAtTime(0.3, now + 0.05);
                g.linearRampToValueAtTime(0.0001, now + c.noteDuration);
                c.noteDuration = 0.15 + Math.random()*0.25;
                c.nextNoteTime = now + 0.4 + Math.random()*0.8;
            }

            c.currentFreq = freq;
        }
    });
}

// -------------------- SPATIAL AUDIO --------------------
function updateAudioSpatial(){
    if(!audioStarted) return;
    audioCtx.listener.positionX.value=camera.position.x;
    audioCtx.listener.positionY.value=camera.position.y;
    audioCtx.listener.positionZ.value=camera.position.z;
    const forward=new THREE.Vector3(0,0,-1).applyEuler(camera.rotation);
    audioCtx.listener.forwardX.value=forward.x; audioCtx.listener.forwardY.value=forward.y; audioCtx.listener.forwardZ.value=forward.z;
    audioCtx.listener.upX.value=0; audioCtx.listener.upY.value=1; audioCtx.listener.upZ.value=0;

    for(let i=0;i<4;i++){
        const src=circleAudio[i];
        const pos=circles[i].mesh.position;
        src.panner.positionX.value=pos.x; src.panner.positionY.value=pos.y; src.panner.positionZ.value=pos.z;
        const dist=camera.position.distanceTo(pos); const maxDist=25; const t=Math.min(dist/maxDist,1);
        const vol=Math.pow(1-t,3); src.gain.gain.linearRampToValueAtTime(vol,audioCtx.currentTime+0.1); src.currentVolume=vol;
        const minCut=600,maxCut=20000; const cutoff=minCut+(maxCut-minCut)*Math.pow(1-t,2.2);
        src.lowpass.frequency.linearRampToValueAtTime(cutoff,audioCtx.currentTime+0.1);
    }
}

// -------------------- VISUALS --------------------
function updateCirclesVisuals(){
    const time=performance.now()/1000;
    for(let i=0;i<4;i++){
        const circleData=circles[i];
        circleData.mesh.position.y=circleData.baseY+Math.sin(time+i)*0.3;
        circleData.currentColor.lerp(circleData.targetColor,0.02);
        circleData.mesh.material.color.copy(circleData.currentColor);
        circleData.mesh.material.emissive.copy(circleData.currentColor);
        const segs=circleSegments[i];
        for(let j=0;j<segs.length;j++){
            const seg=segs[j];
            const freq=circleAudio[i]?.currentFreq||440;
            const amp=circleAudio[i]?.currentVolume||0;
            const len=2*(0.5+amp)*Math.sin(freq*time+j);
            const positions=seg.geom.attributes.position.array;
            positions[0]=0; positions[1]=0; positions[2]=0;
            positions[3]=0; positions[4]=len; positions[5]=0;
            seg.geom.attributes.position.needsUpdate=true;
            const brightness=0.5+0.5*amp;
            seg.line.material.color.copy(circleData.currentColor).multiplyScalar(brightness);
        }
    }
}

// -------------------- RIBBON VISUALIZATION --------------------
let ribbon=null;
let ribbonActive=false;
function createRibbon(){
    const ribbonPoints=[];
    const ribbonSegments=80;
    for(let i=0;i<ribbonSegments;i++) ribbonPoints.push(new THREE.Vector3(0,i*0.1,0));
    const ribbonGeom=new THREE.BufferGeometry().setFromPoints(ribbonPoints);
    const ribbonMat=new THREE.LineBasicMaterial({color:0xff00ff, transparent:true, opacity:0.8});
    ribbon=new THREE.Line(ribbonGeom,ribbonMat);
    scene.add(ribbon);
    ribbonActive=true;
}

function updateRibbon(){
    if(!ribbonActive) return;
    const time=performance.now()/1000;
    const positions=ribbon.geometry.attributes.position.array;
    const segments=positions.length/3;
    for(let i=0;i<segments;i++){
        const idx=i*3;
        positions[idx]=Math.sin(time*0.5+i*0.1)*5;
        positions[idx+1]=i*0.1+2+Math.sin(time*0.2+i*0.05)*0.5;
        positions[idx+2]=Math.cos(time*0.5+i*0.1)*5;
    }
    const hue=(time*40)%360;
    ribbon.material.color.setHSL(hue/360,1,0.5);
    ribbon.geometry.attributes.position.needsUpdate=true;
}

// -------------------- MINI MAP --------------------
const miniMapCanvas=document.getElementById("miniMap");
const miniMapCtx=miniMapCanvas.getContext("2d");
function updateMiniMap(){
    miniMapCtx.fillStyle="#111"; miniMapCtx.fillRect(0,0,150,150);
    const scale=2; const offset=75;
    circles.forEach(c=>{
        miniMapCtx.fillStyle="#0ff";
        miniMapCtx.beginPath();
        miniMapCtx.arc(c.mesh.position.x*scale+offset,c.mesh.position.z*scale+offset,5,0,Math.PI*2);
        miniMapCtx.fill();
    });
    miniMapCtx.fillStyle="#f00";
    miniMapCtx.beginPath();
    miniMapCtx.arc(camera.position.x*scale+offset,camera.position.z*scale+offset,5,0,Math.PI*2);
    miniMapCtx.fill();
}

// -------------------- ANIMATION --------------------
function animate(){
    requestAnimationFrame(animate);
    updateMovement();
    updateMelody();
    updateAudioSpatial();
    updateCirclesVisuals();
    updateMiniMap();
    if(timerSeconds <= 180 && !ribbonActive) createRibbon(); // ribbon at 3 minutes
    updateRibbon();
    renderer.render(scene,camera);
}
animate();

// -------------------- RESIZE --------------------
window.addEventListener("resize",()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
});

// -------------------- START AUDIO BUTTON --------------------
document.getElementById("startAudio").addEventListener("click",startAudio);

</script>
</body>
</html>
